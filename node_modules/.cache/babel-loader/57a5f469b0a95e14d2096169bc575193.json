{"ast":null,"code":"/**\r\n * Script loading is difficult thanks to IE. We need callbacks to fire\r\n * immediately following the script's execution, with no other scripts\r\n * running in between. If other scripts on the page are able to run\r\n * between our script and its callback, bad things can happen, such as\r\n * `jQuery.noConflict` not being called in time, resulting in plugins\r\n * latching onto our version of jQuery, etc.\r\n *\r\n * For IE<10 we use a relatively well-documented \"preloading\" strategy,\r\n * which ensures that the script is ready to execute *before* appending\r\n * it to the DOM. That way when it is finally appended, it is\r\n * executed immediately.\r\n *\r\n * References:\r\n * - http://www.html5rocks.com/en/tutorials/speed/script-loading/\r\n * - http://blog.getify.com/ie11-please-bring-real-script-preloading-back/\r\n * - https://github.com/jrburke/requirejs/issues/526\r\n * - https://connect.microsoft.com/IE/feedback/details/729164/\r\n *           ie10-dynamic-script-element-fires-loaded-readystate-prematurely\r\n */\n(function () {\n  // Global state.\n  var pendingScripts = {};\n  var scriptCounter = 0;\n  /**\r\n   * Insert script into the DOM\r\n   *\r\n   * @param {Object} script Script DOM object\r\n   * @returns {void}\r\n   */\n\n  var _addScript = function _addScript(script) {\n    // Get the first script element, we're just going to use it\n    // as a reference for where to insert ours. Do NOT try to do\n    // this just once at the top and then re-use the same script\n    // as a reference later. Some weird loaders *remove* script\n    // elements after the browser has executed their contents,\n    // so the same reference might not have a parentNode later.\n    var firstScript = document.getElementsByTagName(\"script\")[0]; // Append the script to the DOM, triggering execution.\n\n    firstScript.parentNode.insertBefore(script, firstScript);\n  };\n  /**\r\n   * Load Script.\r\n   *\r\n   * @param {String}    src       URI of script\r\n   * @param {Function}  callback  (Optional) Called on script load completion\r\n   * @param {Object}    context   (Optional) Callback context (`this`)\r\n   * @returns {void}\r\n   */\n\n\n  var _lload = function _lload(src, callback, context) {\n    /*eslint max-statements: [2, 25]*/\n    var script = document.createElement(\"script\");\n    var done = false;\n    var err;\n\n    var _cleanup; // _must_ be set below.\n\n    /**\r\n     * Final handler for error or completion.\r\n     *\r\n     * **Note**: Will only be called _once_.\r\n     *\r\n     * @returns {void}\r\n     */\n\n\n    var _finish = function _finish() {\n      // Only call once.\n      if (done) {\n        return;\n      }\n\n      done = true; // Internal cleanup.\n\n      _cleanup(); // Callback.\n\n\n      if (callback) {\n        callback.call(context, err);\n      }\n    };\n    /**\r\n     * Error handler\r\n     *\r\n     * @returns {void}\r\n     */\n\n\n    var _error = function _error() {\n      err = new Error(src || \"EMPTY\");\n\n      _finish();\n    };\n\n    if (script.readyState && !(\"async\" in script)) {\n      /*eslint-disable consistent-return*/\n      // This section is only for IE<10. Some other old browsers may\n      // satisfy the above condition and enter this branch, but we don't\n      // support those browsers anyway.\n      var id = scriptCounter++;\n      var isReady = {\n        loaded: true,\n        complete: true\n      };\n      var inserted = false; // Clear out listeners, state.\n\n      _cleanup = function _cleanup() {\n        script.onreadystatechange = script.onerror = null;\n        pendingScripts[id] = void 0;\n      }; // Attach the handler before setting src, otherwise we might\n      // miss events (consider that IE could fire them synchronously\n      // upon setting src, for example).\n\n\n      script.onreadystatechange = function () {\n        var firstState = script.readyState; // Protect against any errors from state change randomness.\n\n        if (err) {\n          return;\n        }\n\n        if (!inserted && isReady[firstState]) {\n          inserted = true; // Append to DOM.\n\n          _addScript(script);\n        } // --------------------------------------------------------------------\n        //                       GLORIOUS IE8 HACKAGE!!!\n        // --------------------------------------------------------------------\n        //\n        // Oh IE8, how you disappoint. IE8 won't call `script.onerror`, so\n        // we have to resort to drastic measures.\n        // See, e.g. http://www.quirksmode.org/dom/events/error.html#t02\n        //\n        // As with all things development, there's a Stack Overflow comment that\n        // asserts the following combinations of state changes in IE8 indicate a\n        // script load error. And crazily, it seems to work!\n        //\n        // http://stackoverflow.com/a/18840568/741892\n        //\n        // The `script.readyState` transitions we're interested are:\n        //\n        // * If state starts as `loaded`\n        // * Call `script.children`, which _should_ change state to `complete`\n        // * If state is now `loading`, then **we have a load error**\n        //\n        // For the reader's amusement, here is HeadJS's catalog of various\n        // `readyState` transitions in normal operation for IE:\n        // https://github.com/headjs/headjs/blob/master/src/2.0.0/load.js#L379-L419\n\n\n        if (firstState === \"loaded\") {\n          // The act of accessing the property should change the script's\n          // `readyState`.\n          //\n          // And, oh yeah, this hack is so hacky-ish we need the following\n          // eslint disable...\n\n          /*eslint-disable no-unused-expressions*/\n          script.children;\n          /*eslint-enable no-unused-expressions*/\n\n          if (script.readyState === \"loading\") {\n            // State transitions indicate we've hit the load error.\n            //\n            // **Note**: We are not intending to _return_ a value, just have\n            // a shorter short-circuit code path here.\n            return _error();\n          }\n        } // It's possible for readyState to be \"complete\" immediately\n        // after we insert (and execute) the script in the branch\n        // above. So check readyState again here and react without\n        // waiting for another onreadystatechange.\n\n\n        if (script.readyState === \"complete\") {\n          _finish();\n        }\n      }; // Onerror handler _may_ work here.\n\n\n      script.onerror = _error; // Since we're not appending the script to the DOM yet, the\n      // reference to our script element might get garbage collected\n      // when this function ends, without onreadystatechange ever being\n      // fired. This has been witnessed to happen. Adding it to\n      // `pendingScripts` ensures this can't happen.\n\n      pendingScripts[id] = script; // This triggers a request for the script, but its contents won't\n      // be executed until we append it to the DOM.\n\n      script.src = src; // In some cases, the readyState is already \"loaded\" immediately\n      // after setting src. It's a lie! Don't append to the DOM until\n      // the onreadystatechange event says so.\n    } else {\n      // This section is for modern browsers, including IE10+.\n      // Clear out listeners.\n      _cleanup = function _cleanup() {\n        script.onload = script.onerror = null;\n      };\n\n      script.onerror = _error;\n      script.onload = _finish;\n      script.async = true;\n      script.charset = \"utf-8\";\n      script.src = src; // Append to DOM.\n\n      _addScript(script);\n    }\n  }; // UMD wrapper.\n\n  /*global define:false*/\n\n\n  if (typeof exports === \"object\" && typeof module === \"object\") {\n    // CommonJS\n    module.exports = _lload;\n  } else if (typeof define === \"function\" && define.amd) {\n    // AMD\n    define([], function () {\n      return _lload;\n    });\n  } else {\n    // VanillaJS\n    window._lload = _lload;\n  }\n})();","map":null,"metadata":{},"sourceType":"script"}